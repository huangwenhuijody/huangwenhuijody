<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>è¿›é˜¶æ•°ç‹¬æ¸¸æˆ</title>
  <style>
	body {
	  font-family: Arial, sans-serif;
	  text-align: center;
	  background: #f0f0f0;
	  padding: 20px;
	}
	table {
	  margin: 0 auto;
	  border-collapse: collapse;
	  background: #fff;
	  box-shadow: 0 0 10px rgba(0,0,0,0.1);
	  table-layout: fixed; /* æ–°å¢ */
	}
	td {
	  width: min(10vw, 50px);
	  height: min(10vw, 50px);
	  min-width: 30px;
	  min-height: 30px;
	  max-width: 50px;
	  max-height: 50px;
	  position: relative;
	}
	input {
	  width: 100%;
	  height: 100%;
	  font-size: min(6vw, 30px);
	  max-font-size: 20px;
	  text-align: center;
	  border: 1px solid #ccc;
	  box-sizing: border-box;
	  padding: 2px;
	}
	input[readonly] {
	  background: #eee;
	  font-weight: bold;
	}
	.error {
	  background-color: #fdd !important;
	}
	td.thick-top    { border-top: 3px solid black; }
	td.thick-left   { border-left: 3px solid black; }
	td.thick-right  { border-right: 3px solid black; }
	td.thick-bottom { border-bottom: 3px solid black; }

	.btns {
	  margin-top: 15px;
	}
	button, select {
	  margin: 5px;
	  padding: 8px 16px;
	  font-size: 16px;
	  cursor: pointer;
	}
	#stats {
	  margin-top: 10px;
	  font-size: 16px;
	  color: #333;
	}

	@media (max-width: 600px) {
	  td {
		min-width: 9vw;
		min-height: 9vw;
	  }
	  input {
		font-size: 6vw;
	  }
	  #stats {
		font-size: 14px;
	  }
	  h1 {
		font-size: 1.5rem;
	  }
	}
  </style>
</head>
<body>
  <h1>sudoku</h1>

  <div class="btns">
    <label for="difficulty">éš¾åº¦ï¼š</label>
    <select id="difficulty">
      <option value="45">ç®€å•</option>
      <option value="36">æ™®é€š</option>
      <option value="30" selected>ç¨éš¾</option>
      <option value="24">å›°éš¾</option>
      <option value="17">åœ°ç‹±</option>
    </select>
    <br>
    <button onclick="startGame()">æ–°æ¸¸æˆ</button>
    <button onclick="checkResult()">æ£€æŸ¥ç»“æœ</button>
    <button onclick="giveHint()">ğŸ’¡ æç¤º</button>
  </div>

  <div id="stats">
    â± ç”¨æ—¶ï¼š<span id="timer">00:00</span> | â³ æ­¥æ•°ï¼š<span id="steps">0</span>
  </div>

  <div id="sudoku"></div>

  <script>
    const SIZE = 9;
    let solution = [], timerInterval, time = 0, steps = 0;
    let selectedInput = null;

    function pad(n) { return n < 10 ? '0' + n : n; }

    function updateTimer() {
      time++;
      const min = Math.floor(time / 60);
      const sec = time % 60;
      document.getElementById("timer").textContent = `${pad(min)}:${pad(sec)}`;
    }

    function resetStats() {
      clearInterval(timerInterval);
      time = 0;
      steps = 0;
      document.getElementById("timer").textContent = "00:00";
      document.getElementById("steps").textContent = "0";
    }

    function createBoard() {
      return Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
    }

    function shuffleArray(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    function isValid(board, row, col, num) {
      for (let i = 0; i < SIZE; i++) {
        if (board[row][i] === num || board[i][col] === num) return false;
      }
      const startRow = Math.floor(row / 3) * 3;
      const startCol = Math.floor(col / 3) * 3;
      for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
          if (board[startRow + i][startCol + j] === num) return false;
      return true;
    }

    function fillBoard(board, row = 0, col = 0) {
      if (row === SIZE) return true;
      let nextRow = row, nextCol = col + 1;
      if (nextCol === SIZE) { nextRow = row + 1; nextCol = 0; }
      if (board[row][col] !== 0) return fillBoard(board, nextRow, nextCol);
      const nums = [1,2,3,4,5,6,7,8,9];
      shuffleArray(nums);
      for (const num of nums) {
        if (isValid(board, row, col, num)) {
          board[row][col] = num;
          if (fillBoard(board, nextRow, nextCol)) return true;
          board[row][col] = 0;
        }
      }
      return false;
    }

    function generateSudoku() {
      const board = createBoard();
      fillBoard(board);
      return board;
    }

    function createPuzzle(fullBoard, clueCount = 30) {
      const puzzle = fullBoard.map(row => row.slice());
      let cellsToHide = SIZE * SIZE - clueCount;
      while (cellsToHide > 0) {
        const i = Math.floor(Math.random() * SIZE);
        const j = Math.floor(Math.random() * SIZE);
        if (puzzle[i][j] !== 0) {
          puzzle[i][j] = 0;
          cellsToHide--;
        }
      }
      return puzzle;
    }

    function displayBoard(puzzle) {
      const container = document.getElementById("sudoku");
      container.innerHTML = "";
      const table = document.createElement("table");

      for (let i = 0; i < SIZE; i++) {
        const row = document.createElement("tr");
        for (let j = 0; j < SIZE; j++) {
          const cell = document.createElement("td");
          if (i % 3 === 0) cell.classList.add("thick-top");
          if (j % 3 === 0) cell.classList.add("thick-left");
          if (j === SIZE - 1) cell.classList.add("thick-right");
          if (i === SIZE - 1) cell.classList.add("thick-bottom");

          const input = document.createElement("input");
          input.dataset.row = i;
          input.dataset.col = j;

          if (puzzle[i][j] !== 0) {
            input.value = puzzle[i][j];
            input.readOnly = true;
          } else {
            input.addEventListener("input", () => {
              validateInput(input);
              steps++;
              document.getElementById("steps").textContent = steps;
            });
            input.addEventListener("focus", () => selectedInput = input);
          }
          cell.appendChild(input);
          row.appendChild(cell);
        }
        table.appendChild(row);
      }
      container.appendChild(table);
    }

    function validateInput(input) {
      input.classList.remove("error");
      const val = parseInt(input.value);
      const row = parseInt(input.dataset.row);
      const col = parseInt(input.dataset.col);
      if (isNaN(val) || val < 1 || val > 9) return;

      const inputs = document.querySelectorAll("input");
      for (let other of inputs) {
        if (other === input) continue;
        const r = parseInt(other.dataset.row);
        const c = parseInt(other.dataset.col);
        if (parseInt(other.value) === val &&
            (r === row || c === col || (Math.floor(r/3) === Math.floor(row/3) && Math.floor(c/3) === Math.floor(col/3)))) {
          input.classList.add("error");
          return;
        }
      }
    }
	function checkResult() {
		const inputs = document.querySelectorAll("input");
		const board = Array.from({ length: SIZE }, () => Array(SIZE).fill(0)); // åˆ›å»ºä¸€ä¸ª 9x9 çš„äºŒç»´æ•°ç»„æ¥å­˜å‚¨å½“å‰ç›˜é¢çŠ¶æ€
		let isComplete = true; // æ ‡è®°ç›˜é¢æ˜¯å¦å¡«å†™å®Œæ•´

		// 1. æ¸…é™¤æ—§é”™è¯¯æ ‡è®°ï¼Œå¹¶æ„å»ºå½“å‰ç›˜é¢æ•°ç»„
		inputs.forEach(input => {
			input.classList.remove("error"); // æ¸…é™¤ä¹‹å‰çš„é”™è¯¯é«˜äº®
			const r = parseInt(input.dataset.row);
			const c = parseInt(input.dataset.col);
			const val = parseInt(input.value);

			if (isNaN(val) || val < 1 || val > 9) {
				isComplete = false; // å¦‚æœæ ¼å­ä¸ºç©ºæˆ–æ— æ•ˆæ•°å­—ï¼Œåˆ™ç›˜é¢æœªå®Œæˆ
				board[r][c] = 0; // ç”¨ 0 è¡¨ç¤ºç©ºæ ¼æˆ–æ— æ•ˆè¾“å…¥
			} else {
				board[r][c] = val; // è®°å½•ç”¨æˆ·è¾“å…¥çš„æœ‰æ•ˆæ•°å­—
			}
		});

		let hasConflict = false; // æ ‡è®°æ˜¯å¦å­˜åœ¨å†²çª

		// 2. æ£€æŸ¥è¡Œã€åˆ—ã€ä¹å®«æ ¼æ˜¯å¦æœ‰å†²çª (é‡å¤æ•°å­—)
		for (let r = 0; r < SIZE; r++) {
			for (let c = 0; c < SIZE; c++) {
				const num = board[r][c];
				if (num === 0) continue; // è·³è¿‡ç©ºæ ¼æˆ–æ— æ•ˆæ•°å­—

				// æ£€æŸ¥åŒä¸€è¡Œæ˜¯å¦æœ‰é‡å¤ (åªæ£€æŸ¥å½“å‰æ ¼å­å³ä¾§çš„å³å¯ï¼Œé¿å…é‡å¤æ£€æŸ¥)
				for (let k = c + 1; k < SIZE; k++) {
					if (board[r][k] === num) {
						getInput(r, c).classList.add('error');
						getInput(r, k).classList.add('error'); // å°†å†²çªçš„ä¸¤ä¸ªæ ¼å­éƒ½æ ‡çº¢
						hasConflict = true;
					}
				}

				// æ£€æŸ¥åŒä¸€åˆ—æ˜¯å¦æœ‰é‡å¤ (åªæ£€æŸ¥å½“å‰æ ¼å­ä¸‹æ–¹çš„å³å¯)
				for (let k = r + 1; k < SIZE; k++) {
					if (board[k][c] === num) {
						getInput(r, c).classList.add('error');
						getInput(k, c).classList.add('error');
						hasConflict = true;
					}
				}

				// æ£€æŸ¥åŒä¸€ä¸ª 3x3 ä¹å®«æ ¼æ˜¯å¦æœ‰é‡å¤
				const startRow = Math.floor(r / 3) * 3;
				const startCol = Math.floor(c / 3) * 3;
				for (let i = 0; i < 3; i++) {
					for (let j = 0; j < 3; j++) {
						const boxR = startRow + i;
						const boxC = startCol + j;
						// åªæ£€æŸ¥å½“å‰æ ¼å­ä¹‹åï¼ˆæŒ‰å…ˆè¡Œååˆ—é¡ºåºï¼‰çš„æ ¼å­ï¼Œé¿å…é‡å¤æ£€æŸ¥å’Œè‡ªèº«æ¯”è¾ƒ
						if (boxR > r || (boxR === r && boxC > c)) {
							if (board[boxR][boxC] === num) {
								getInput(r, c).classList.add('error');
								getInput(boxR, boxC).classList.add('error');
								hasConflict = true;
							}
						}
					}
				}
			}
		}

		// è¾…åŠ©å‡½æ•°ï¼šæ ¹æ®è¡Œå’Œåˆ—è·å–å¯¹åº”çš„ input å…ƒç´ 
		function getInput(r, c) {
			return document.querySelector(`input[data-row="${r}"][data-col="${c}"]`);
		}

		// 3. æ ¹æ®æ£€æŸ¥ç»“æœç»™å‡ºæç¤º
		if (hasConflict) {
			alert("âš ï¸ å­˜åœ¨å†²çªçš„æ•°å­—ï¼Œè¯·æ£€æŸ¥çº¢è‰²é«˜äº®å•å…ƒæ ¼ã€‚");
		} else if (!isComplete) {
			alert("âš ï¸ ç›˜é¢æœªå®Œæˆï¼Œè¯·å¡«æ»¡æ‰€æœ‰ç©ºæ ¼ã€‚");
		} else {
			// å¦‚æœä»£ç æ‰§è¡Œåˆ°è¿™é‡Œï¼Œè¯´æ˜ç›˜é¢å·²å®Œæˆä¸”æ²¡æœ‰å†²çª
			alert("ğŸ‰ å¤ªæ£’äº†ï¼Œå…¨éƒ¨æ­£ç¡®ï¼");
			// ï¼ˆå¯é€‰ï¼‰åœ¨è¿™é‡Œåœæ­¢è®¡æ—¶å™¨
			 clearInterval(timerInterval);
		}
	}
    function giveHint() {
      if (!selectedInput || selectedInput.readOnly) return;
      const r = parseInt(selectedInput.dataset.row);
      const c = parseInt(selectedInput.dataset.col);
      selectedInput.value = solution[r][c];
      validateInput(selectedInput);
      steps++;
      document.getElementById("steps").textContent = steps;
    }

    function startGame() {
      resetStats();
      timerInterval = setInterval(updateTimer, 1000);

      const diff = parseInt(document.getElementById("difficulty").value);
      solution = generateSudoku();
      const puzzle = createPuzzle(solution, diff);
      displayBoard(puzzle);
    }

    window.onload = startGame;
  </script>
</body>
</html>
